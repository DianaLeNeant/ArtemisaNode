var lpath = String(__dirname).replace(/node_modules$/g, '') + "/";

var files = require('fs');
var colors = require('colors');
var getJSON = require('get-json');
var fx = require("money");
var moment = require('moment');

var eDate = moment();
const logname = String(eDate.format('YYYY-MM-DD HH.mm.ss').toString())
const output = files.createWriteStream('Artemisa' + logname + '.log');
const dboutput = files.createWriteStream('ArtemisaDB' + logname + '.log');
const errorOutput = files.createWriteStream('ArtemisaError'+ logname +'.log');
const errordboutput = files.createWriteStream('ArtemisaDBError' + logname + '.log');
var readline = require('readline');
const log = new console.Console( output, errorOutput );
const dblog = new console.Console( dboutput, errordboutput );

function exchangeRates() {
    // 853faf97eeec4ad98cebdab10f2ff95e --> openexchangerates.com API key
    cLog('!!! ---> Requesting actual Exchange Rates ...');
    getJSON('https://openexchangerates.org/api/latest.json?app_id=853faf97eeec4ad98cebdab10f2ff95e',function(error, data) {
        cLog(`!!! --->  ${JSON.stringify(data)}`);
        if ( typeof fx !== "undefined" && fx.rates ) {
            fx.rates = data.rates;
            fx.base = data.base;
        } else {
            // If not, apply to fxSetup global:
            var fxSetup = {
                rates : data.rates,
                base : data.base
            }
        }
    });
}
function prExchange(price, from) {
    try {
        var cc = fx(price).convert({ from:from, to:"MXN" });
        return Number(cc).toFixed(2);   
    } catch (error) {
        cLog(`  --->!!! Error exchanging price (${price} as ${from} to MXN)`);
        return Number(price);
    }
}

function cLog(t) {
    var dtStr = moment().format('DD/MM/YYYY HH:mm:ss').toString();
    log.log('Log [' + dtStr + '] > ' + t);
    readline.cursorTo(process.stdout, 0);
    console.log('Log '.cyan.bold + '['.yellow + dtStr.gray.italic + '] > '.yellow + cString(t));
}
function dLog(t) {
    var dtStr = moment().format('DD/MM/YYYY HH:mm:ss').toString();
    dblog.log('DB [' + dtStr + '] > ' + t);
}
function cString(str) {
    var ret = '';
    for (let i = 0; i < str.length; i++) {
        const c = str.charAt(i);
        switch (c) {
            case '-':
                ret += String(c).green;
            break;
            case '\\': case '/':
                ret += String(c).magenta.bold;
            break;
            case '{': case '}': case '[': case ']':
                ret += String(c).yellow.bold;
            break;
            case '<': case '>':
                ret += String(c).blue.bold;
            break;
            case ':':
                ret += String(c).cyan.bold;
            break;
            case '!':
                ret += String(c).red.bold;
            break;
            default:
                ret += String(c).white.italic;
            break;
        }
    }
    return ret;
}

function secureParse(str) {
    if (!str) return undefined;
    if (str.constructor === Object) return str;
    if (str.constructor !== String) return undefined;

    if (files.existsSync(lpath + 'config/' + str)) {
        var s = files.readFileSync(lpath + 'config/' + str, 'utf8').replace('\t', '');
        var ret;
        while (s.includes('\t')) {
            s = s.replace('\t', '')
        }
        try {
            ret = JSON.parse(s.replace('\t', ''));
        } catch (error) {
            ret = undefined;
        }
        return ret;
    } else {
        var s = str.replace('\t', '');
        var ret;
        while (s.includes('\t')) {
            s = s.replace('\t', '')
        }
        try {
            ret = JSON.parse(s.replace('\t', ''));
        } catch (error) {
            ret = undefined;
        }
        return ret;
    }
}

function consultConfigurationList(file, section) {
    var ret = secureParse(String(file) + '.json');

    if (ret) {
        if (!section) {
            return Object.keys(ret);
        } else if(ret[section]) {
            return Object.keys(ret[section]);
        } else {
            return undefined;
        }
    } else {
        return undefined;
    }
}
function consultConfiguration(file, section, subsection) {
    var ret = secureParse(String(file) + '.json');

    if (ret) {
        if (ret[section] && !subsection) {
            return ret[section];
        } else if(ret[section] && subsection) {
            if (ret[section][subsection]) {
                return ret[section][subsection];
            } else {
                return ret[section]['default'];
            }
        } else {
            return ret['default'];
        }
    } else {
        return undefined;
    }
}

exchangeRates();

module.exports = {
    logname: function() { return 'Artemisa' + logname + '.log' },
    elogname: function() { return 'ArtemisaError' + logname + '.log' },
    dblogname: function() { return 'ArtemisaDB' + logname + '.log' },
    dbelogname: function() { return 'ArtemisaDBError' + logname + '.log' },
    cLog: cLog,
    dLog: dLog,
    consultConfiguration: consultConfiguration,
    consultAreas: function(accessString = String()) {
        var areaInfo = consultConfigurationList('areas');
        var ret = {
            isAdmon: false,
            isRestricted: false,
            isAbsent: false,
            areas: [],
            flags: [],
            isOnArea: function(area) {
                for (let x = 0; x < this.areas.length; x++) {
                    if (this.areas[x].name == area) {
                        return true;
                    }
                }
                return false;
            }
        };

        if (areaInfo) {
            for (let x = 0; x < areaInfo.length; x++) {
                if (String(accessString).toLowerCase().includes(String(areaInfo[x]))) {
                    var thisArea = consultConfiguration('areas', String(areaInfo[x]));

                    if (thisArea.admon) { ret.isAdmon = true; }
                    if (thisArea.restrictedUser) { ret.isRestricted = true; }
                    if (thisArea.absentStatus) { ret.isAbsent = true; }
                    if (thisArea.flag) { ret.flags.push(areaInfo[x]); }

                    thisArea.name = areaInfo[x];

                    ret.areas.push(thisArea);
                }
            }
        }

        if (ret.areas.length == 0) {
            ret.areas.push(consultConfiguration('areas', 'default'));
        }

        return ret;
    },
    consultStatus: function(status) {
        var st = consultConfiguration('status', status);

        if (!st) {
            return {
                isCanceled: false,
                isInvalid: true,
                isIDLE: false,
                isAlert: false,
                isTransitory: false
            };
        }

        return {
            isCanceled: st["canceledStatus"],
            isInvalid: st["invalidStatus"],
            isIDLE: st["idleStatus"],
            isAlert: st["alertStatus"],
            isTransitory: st["transitStatus"]
        };
    },
    secureParse: secureParse,
    sessions: {},
    setSession: function(clientIp, logonArea, dbInfo, sckt) {
        if (!this.sessionExists(clientIp)) {
            this.sessions[clientIp] = {
                ip: clientIp,
                socket: sckt,
                area: logonArea,
                user_info: dbInfo
            };
            this.cLog(`           ---> [ Session Created // ${clientIp} ]`);
        } else {
            this.sessions[clientIp].ip = clientIp;
            this.sessions[clientIp].area = logonArea;
            this.sessions[clientIp].user_info = dbInfo;
            this.sessions[clientIp].socket = sckt;
        }
    },
    prExchange: prExchange,
    prExchangeUpdate: function() {
        exchangeRates()
    },
    sessionExists: function(clientIp) {
        if (this.sessions[clientIp] != undefined) {
            return true;
        } else {
            this.cLog(`           ---> [ Invalid session // ${clientIp} ]`);
            return false;
        }
    },
    isOnAccess: function (clientIp, area) {
        if (this.sessionExists(clientIp)) {
            if (area.includes(this.sessions[clientIp].user_info.Area)) {
                var access = this.sessions[clientIp].user_info.Acceso.split(':');
                if (area.includes(access[0]) || access[0] == "total") {
                    return access[1];
                } else {
                    this.cLog(`           ---> [ Invalid access: Invalid Database Access! // ${this.sessions[clientIp]}]`);
                    return false
                }
            } else {
                this.cLog(`           ---> [ Invalid access: Invalid Session Access! // ${this.sessions[clientIp]}]`);
                return false;
            }
        } else {
            this.cLog(`           ---> [ Invalid access: Invalid Session! // ${this.sessions[clientIp]}]`);
            return false;
        }
    }
}