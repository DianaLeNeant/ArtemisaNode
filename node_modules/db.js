/**
 * Server DB communication file.
 *
 * @link   https://github.com/DianaLeNeant/ArtemisaNode
 * @author Diana Celeste Nuño Ramírez. 2018.
 */

/* ---[ RESULT OBJECT SCHEMA ]---

    {
        fieldCount: 0,
        affectedRows: 14,
        insertId: 0,
        serverStatus: 2,
        warningCount: 0,
        message: '\'Records:14  Duplicated: 0  Warnings: 0',
        protocol41: true,
        changedRows: 0
    }

    OR

    [ {
        column_name: 'value',
        ...
    },
    {
        ...
    } ]

*/
var artemisa = require('artemisa');

module.exports = {
    mysql: require('mysql'),
    connection: null,
    start: function() {
        this.connection = this.mysql.createConnection({
            host: "localhost",
            user: "node",
            password: "ssA100BBueMMsJsraa",
            database: 'artemisa'
        });
    },
    end: function() {
        if (this.connection) {
            this.connection.end();
        }
    },
    query: function (q, callBack = function(result) {}) {
        this.start();
        var con = this.connection;
        if (con != undefined) {
            con.connect(function(err) {
                if (err) {
                    artemisa.cLog(`-- [ database error: '${q} --> ${err}' ] --`);
                    artemisa.dLog(`-- [ database error: '${q} --> ${err}' ] --`);
                    con.end();
                    callBack(false); return;
                }
                artemisa.cLog(`-- [ database query: '${q}' ] --`);
                artemisa.dLog(`-- [ database query: '${q}' ] --`);

                con.query(q, function (err, result) {
                    if (err) {
                        artemisa.cLog(`-- [ database error: '${q} --> ${err}' ] --`);
                        artemisa.dLog(`-- [ database error: '${q} --> ${err}' ] --`);
                        con.end();
                        callBack(false); return;
                    }
                    artemisa.cLog(`   }-- [ query successful: '${q} --> ${ (result.message != undefined ? result.message : result.length) }' ] --`);
                    artemisa.dLog(`   }-- [ query successful: '${q} --> ${ (result.message != undefined ? result.message : result.length) }' ] --`);
                    callBack(result);
                    con.end();
                });
            });
        }
    },
    queryList: function (q, id, callBack = function(result) {}) {
        this.start();
        var con = this.connection;
        if (con != undefined) {
            con.connect(function(err) {
                if (err) {
                    artemisa.cLog(`-- [ database error: '${q} --> ${err}' ] --`);
                    artemisa.dLog(`-- [ database error: '${q} --> ${err}' ] --`);
                    con.end();
                    callBack(false); return;
                }
                artemisa.cLog(`-- [ database query: '${q}' ] --`);
                artemisa.dLog(`-- [ database query: '${q}' ] --`);

                con.query(q, function (err, result) {
                    if (err) {
                        artemisa.cLog(`-- [ database error: '${q} --> ${err}' ] --`);
                        artemisa.dLog(`-- [ database error: '${q} --> ${err}' ] --`);
                        con.end();
                        callBack(false); return;
                    }
                    artemisa.cLog(`   }-- [ query successful: '${q} --> ${ (result.message != undefined ? result.message : result.length) }' ] --`);
                    artemisa.dLog(`   }-- [ query successful: '${q} --> ${ (result.message != undefined ? result.message : result.length) }' ] --`);
                    var ret = {};
                    for (var i in result) {
                        ret[result[i][id]] = result[i];
                    }
                    callBack(ret);
                    con.end();
                });
            });
        }
    },
    getCategory: function (table, cat = "Nombre", id = "ID", callBack = function(result) {}) {
        this.query(`SELECT ${id}, ${cat} FROM ${table};`, function(res) {
            if (res.length > 0) {
                callBack(res);
            } else {
                callBack(false);
            }
        });
    },
    getCategoryList: function (table, cat = "Nombre", id = "ID", callBack = function(result) {}) {
        this.query(`SELECT ${id}, ${cat} FROM ${table};`, function(res) {
            if (res.length > 0) {
                var ret = {};
                for (var i = 0; i < res.length; i++) {
                    ret[res[i][id]] = res[i][cat];
                }
                callBack(ret);
            } else {
                callBack(false);
            }
        });
    },
    resToList: function (res, cat = "Nombre", id = "ID") {
        var ret = {};
        if (res.length == 0) { return null; }
        if (!res) { return null;}
        if (!res[0][id]) {
            var ks = Object.keys(res[0]);
            id = ks[0];
        }
        if (!res[0][cat]) {
            var ks = Object.keys(res[0]);
            cat = ks[1];
        }
        for (var i in res) {
            ret[res[i][id]] = res[i][cat];
        }
        return ret;
    },

    /*
        Queries:
            [query, where filter, column replacement]
            [0] = Category query
            [1] = Subcategory query
            [2] = Main data source
            [...] = The rest to be taken as replacement for foreign keys values

            'Column replacement' element in the array represents a column name
            in the main data source, specially a foreing key column. This column
            value in the result will be replaced with the foreign table value in
            the main data source result.
    */

    /**
     * Takes a list of queries to the database and returns an object with columns and rows.
     * 
     * Query list remarks: First element is the category. Takes the query result to construct the tree with categories;
     * the second element will be taken for sub-categories (if subcategory param is true). Third element will be taken
     * as the main source of data to be categorized (Category -> Subcategory -> data from third element).
     * 
     * @param {Array} queries Query list to consult to the database, have to be a 2D array. Format above.
     * @param {Boolean} subcategory Whether to parse results as category / subcategory or only category.
     * @param {Array} column_mask List of column headers names to be shown for the final user, as a replacement for the original ones at the database table.
     * @param {String} classes Classes to be added to the html table when the result is shown to the final user.
     * @param {String} prdesc Column where to get the caption for an unique result in the treeview control when the result is shown to the final user.
     * @param {Function} callBack Function callback to be invoked when the process is done. Takes one argument with the resulting object.
     */
    objectize: function (queries, subcategory = true, column_mask = null, classes = '', prdesc = 'Nombre', callBack = function(resultObject) {}) {
        var q = [];
        var p = 0;
        for (let qI = 0; qI < queries.length; qI++) {
            if (queries[qI][2] != undefined) {
                q.push( {
                    query: queries[qI][0].replace('{where}', (queries[qI][1] != '' ? ((queries[qI][0].includes('WHERE') ? 'AND ' : 'WHERE ') + queries[qI][1]) : '')),
                    result: null,
                    relation: queries[qI][2]
                 } )
            } else {
                q.push( {
                    query: queries[qI][0].replace('{where}', (queries[qI][1] != '' ? ((queries[qI][0].includes('WHERE') ? 'AND ' : 'WHERE ') + queries[qI][1]) : '')),
                    result: null,
                    relation: null
                 } )
            }
        }
        artemisa.cLog(` - ${q.length} / ${subcategory} -`)
        var fi = false;
        var toQuery = function (qO, ite, finish) {
                                        if (q[p] == undefined) {
                                            if (fi) return;
                                            finish(qO);
                                            fi = true;
                                            return;
                                        }
                                        artemisa.cLog(` - iterating... [ ${p + 1} / ${q.length} ] -`)
                                        qO.query(q[p].query, function(resA) {
                                            q[p].result = resA;
                                            artemisa.cLog(`     - result: ${q[p].result.length} -`);
                                            p++;
                                            ite(qO, ite, finish);
                                        });
                                    };
        var pro = function(qO) {
            var resC = qO.resToList(q[0].result);
            var resSCat = (subcategory ? qO.resToList(q[1].result) : null);
            var resP = (subcategory ? q[2].result : q[1].result);
            if (resP.length < 1) {
                artemisa.cLog('returning...');
                callBack({}); return;
            }
            var categorias = {
                prDescriptor: prdesc,
                prColumns: Object.keys(resP[0]),
                prColumnsM: column_mask,
                prClass: classes
            };

            var catMask = q[0].relation;
            var sCatMask = (subcategory ? q[1].relation : null);

            for (let j = 0; j < resP.length; j++) {
                if (!resC) continue;
                var pr = resP[j]; var npr = {};
                if (!pr) continue;

                var cat = String(resC[pr[catMask]]).trim();
                var scat = undefined;
                if (pr && resSCat) {
                    scat = (subcategory ? String(resSCat[pr[sCatMask]]).trim() : undefined);
                }
                if (scat == 'undefined') scat = undefined;
                var prK = Object.keys(pr);
                if ((cat != undefined && scat != undefined) || (cat != undefined && subcategory == false)) {
                    if (cat == 'undefined') continue;
                    for (let x = 0; x < prK.length; x++) {
                        var elPrk = prK[x];
                        var elCM = column_mask[x];
                        var elStr = pr[elPrk];
                        for (let z = 0; z < q.length; z++) {
                            const rel = q[z].relation;
                            if (rel) {
                                if (String(rel).toLowerCase().trim() == String(elPrk).toLowerCase().trim()) {
                                    const res = qO.resToList(q[z].result);
                                    if (res != null) {
                                        if (res[pr[elPrk]]) {
                                            elStr = res[pr[elPrk]];
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (elStr == undefined) {
                            continue;
                        }
                        
                        if (elCM != undefined) {
                            if (prK.includes('Moneda')) {
                                if (elPrk == 'VentaTienda' || elPrk == 'VentaCC') {
                                    var mon = pr['Moneda'];
                                    switch (mon) {
                                        case 2: mon = 'USD'; break;
                                        case 3: mon = 'EUR'; break;
                                        case 4: mon = 'JPY'; break;
                                        default: mon = 'MXN'; break;
                                    }
                                    if (mon != 'MXN') {
                                        var nStr = artemisa.prExchange(Number(elStr), mon);
                                        elStr = nStr;
                                    }
                                }
                            }
                            npr[elCM] = elStr;
                        } else { continue; }

                        if (subcategory) {
                            if (categorias[cat] == undefined) {
                                categorias[cat] = {
                                    subc: {}
                                }
                                categorias[cat].subc[scat] = new Array(npr);
                            } else {
                                if (categorias[cat].subc[scat] == undefined) {
                                    categorias[cat].subc[scat] = new Array(npr);
                                } else {
                                    if (!categorias[cat].subc[scat].includes(npr)) {
                                        categorias[cat].subc[scat].push(npr);
                                    }
                                }
                            }
                        } else {
                            if (categorias[cat] == undefined) {
                                categorias[cat] = {
                                    pr: new Array(npr)
                                }
                            } else {
                                if (categorias[cat].pr == undefined) {
                                    categorias[cat].pr = new Array(npr);
                                } else {
                                    if (!categorias[cat].pr.includes(npr)) {
                                        categorias[cat].pr.push(npr);
                                    }
                                }
                            }
                        }
                        delete npr; delete pr;
                    }
                }
            }
            callBack(categorias);
            delete categorias;
        }
        
        artemisa.cLog(` - iterating... -`)
        toQuery(this, toQuery, pro);
    }
};
